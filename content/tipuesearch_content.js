var tipuesearch = {"pages": [{'title': 'Introduction', 'text': 'Group\xa0website:\xa0 stage2-ag1 \n Group \xa0 repository \xa0 : \xa0 stage2-ag1 \n Group \xa0 Heroku \xa0 : \xa0 stage2-ag1 \n Group\xa0reveal.js\xa0:\xa0 stage2-ag1', 'tags': '', 'url': 'Introduction.html'}, {'title': 'Work Distribution', 'text': '40823108 \xa0:  coppeliasim 程式編寫與模擬、pdf報告製作、零件繪圖 \n 40823109 \xa0: 零件繪圖 \n 40823112 \xa0: coppeliasim 程式編寫與模擬、小組倉儲網站編輯、reveal報告製作 \n 40823145 \xa0: 小組倉儲網站編輯 \n', 'tags': '', 'url': 'Work Distribution.html'}, {'title': 'Cooperation', 'text': '協同設計與版次管理能夠有效提升團隊工作效率，降低內容互相覆蓋，最終造成無法辨識是誰更改內容的情況。 \n \n 領導主幹設立項目Project所需目標要求，主導至最終完成，協作者分支Branch由主幹分配負責工作區或衍生不同設計，各分支皆達到目標需求後合併回主幹，方能生產項目。 \n \n 因協作者的工作與內容更動皆在獨立分支清清楚楚，責任歸屬的也就一目了然。 \n 分支出來的設計，在本次目標不需要，或許未來的項目可以用上。可以避免掉「當初做過，但改掉了，這次又要重做」這種事情發生 \n \n 組長在倉儲Setting->Manage access->Invite a collaborato邀請協作者 \n 組員在自己倉儲中Setting->Manage access->Invite a collaborato組長(組員不用互邀) \n git clone --recurse-submodules https://github.com/a40823112/stage2-ag1.git stage2-ag1 (clone組長倉儲)\ncd stage2-ag1\ngit remote add 40823145 https://github.com/40823145/stage2-ag1.git (add自己倉儲)\n \n', 'tags': '', 'url': 'Cooperation.html'}, {'title': 'Weekly progress', 'text': '', 'tags': '', 'url': 'Weekly progress.html'}, {'title': 'W6', 'text': '分組討論完，決定Stage2的 產品設計內容，為Stage1-ag1的產品進行改良，並新增其它功能: \n 1.利用鍵盤方向鍵操控 \n 2.增加接近傳感器使產品自動行走時，不會撞到障礙物 \n \n', 'tags': '', 'url': 'W6.html'}, {'title': 'W7\xa0Keyboard Control', 'text': '利用鍵盤操控物體行走 \n ( 🔽程式碼 ) \n function sysCall_init() \n    left_handle= sim.getObjectHandle(\'left_m\')\n    right_handle= sim.getObjectHandle(\'right_m\')\n    MaxVel=2\n    leftvelocity=0\n    rightvelocity=0\n    dVel=0.5;\n    --sim.setJointTargetVelocity(left_handle,leftvelocity)\n    --sim.setJointTargetVelocity(right_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_handle, 0)\n                sim.setJointForce(right_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_handle, 10000)\n                --sim.setJointForce(right_handle, 10000)\n            end\n            if (auxiliaryData[1]==2007) then\n                -- up key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-maxvel then="" leftvelocity="-MaxVel" end="" if="" rightvelocity="">MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-maxvel then="" rightvelocity="-MaxVel" end="" --sim="" setjointtargetvelocity="" left_front_handle="" leftvelocity="" sim="" setjointtargetvelocity="" left_back_handle="" leftvelocity="" sim="" setjointtargetvelocity="" right_back_handle="" rightvelocity="" --sim="" setjointtargetvelocity="" right_front_handle="" rightvelocity="" end="" pre=""> -maxvel -maxvel \n \n', 'tags': '', 'url': 'W7\xa0Keyboard Control.html'}, {'title': '模擬問題與排解', 'text': '問題:  當本體開啟運動模擬時會產生錯誤，導致產品解體 \n \n \n 問題原因:  討論後發現，產品的模擬干涉太多使其無法正常運作，原因是產品的輪子跟球體上並不是完整的圓，而是由許多正方形的小格子所構成，所以在模擬時產生過多的干涉影響電腦正常模擬，因而模擬錯誤。 \n \n \n 問題排解: \xa0在coppeliasim內 add->primitive shape->Cylinder 增添簡化圖形來代替原本的車輪，而原本的輪子就做為Disc的造型。 \n \n \n \n', 'tags': '', 'url': '模擬問題與排解.html'}, {'title': 'W8 Sensor Control', 'text': '增加接近傳感器使產品自動行走時，不會撞到障礙物 \n ( 🔽程式碼 ) \n function sysCall_init()\n    \n    \nend\n\nfunction sysCall_actuation()\n    \nend\n\nfunction sysCall_sensing()\n    \nend\n\nfunction sysCall_cleanup()\n    \nend\n\n\n\nfunction sysCall_afterDelete(inData)\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." was deleted")\n    end\n    \nend\n\nfunction sysCall_afterCreate(inData)\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..value.." was created")\n    end\nend\n--]]\nfunction speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    \n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) \n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") \n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") \n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") \n    minMaxSpeed={120*math.pi/180,300*math.pi/180} \n    backUntilTime=-1 \n   \n        xml = \' \'..[[\n         \n         \n         \n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*1\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) \n    \n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        \n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        \n        sim.setJointTargetVelocity(leftMotor,-speed/5)\n        sim.setJointTargetVelocity(rightMotor,-speed/200)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend\n \n', 'tags': '', 'url': 'W8 Sensor Control.html'}, {'title': 'Sensor模擬問題與排解', 'text': '問題: 程式與感測器都確認無誤後，卻還是無法做動。 \n \n \n 問題原因: 與組員討論後發現， 感測器都沒有發生問題，不會做動的原因是程式打錯才無法驅動馬達。 \n \n 問題排解: 更改產品物件的程式碼即可。', 'tags': '', 'url': 'Sensor模擬問題與排解.html'}, {'title': 'W9', 'text': '程式模擬影片與PDF報告 \n 方向鍵控制模擬 \n \n 感測器模擬 \n \n PDF報告 \n', 'tags': '', 'url': 'W9.html'}]};