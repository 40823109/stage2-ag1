var tipuesearch = {"pages": [{'title': 'Introduction', 'text': 'Group\xa0website:\xa0 stage2-ag1 \n Group \xa0 repository \xa0 : \xa0 stage2-ag1 \n Group \xa0 Heroku \xa0 : \xa0 stage2-ag1 \n <<<<<<< HEAD \n', 'tags': '', 'url': 'Introduction.html'}, {'title': 'Work Distribution-1', 'text': '40823108 \xa0:ㄏㄏㄏㄏㄏ \n 40823109 \xa0: \n 40823112 \xa0: \n 40823145 \xa0: \n', 'tags': '', 'url': 'Work Distribution-1.html'}, {'title': 'Work Distribution-2', 'text': '40823108 \xa0:  coppeliasim 程式編寫與模擬、pdf報告製作、零件繪圖 \n 40823109 \xa0: 零件繪圖 \n 40823112 \xa0: coppeliasim 程式編寫與模擬、小組倉儲網站編輯、reveal報告製作 \n 40823145 \xa0: 小組倉儲網站編輯 \n', 'tags': '', 'url': 'Work Distribution-2.html'}, {'title': 'Cooperation', 'text': '>>>>>>> 5cd9c0128002df459e6e0b3f576726fab9f40350 \n 協同設計與版次管理能夠有效提升團隊工作效率，降低內容互相覆蓋，最終造成無法辨識是誰更改內容的情況。 \n \n 領導主幹設立項目Project所需目標要求，主導至最終完成，協作者分支Branch由主幹分配負責工作區或衍生不同設計，各分支皆達到目標需求後合併回主幹，方能生產項目。 \n \n 因協作者的工作與內容更動皆在獨立分支清清楚楚，責任歸屬的也就一目了然。 \n 分支出來的設計，在本次目標不需要，或許未來的項目可以用上。可以避免掉「當初做過，但改掉了，這次又要重做」這種事情發生 \n \n 組長在倉儲Setting->Manage access->Invite a collaborato邀請協作者 \n 組員在自己倉儲中Setting->Manage access->Invite a collaborato組長(組員不用互邀) \n git clone --recurse-submodules https://github.com/a40823112/stage2-ag1.git stage2-ag1 (clone組長倉儲)\ncd stage2-ag1\ngit remote add 40823145 https://github.com/40823145/stage2-ag1.git (add自己倉儲)\n \n', 'tags': '', 'url': 'Cooperation.html'}, {'title': 'Weekly progress', 'text': '', 'tags': '', 'url': 'Weekly progress.html'}, {'title': 'W5', 'text': "第五週分組專案開始，分組以第一次分組兩兩合併為主。 \n 組別為:stage2-ag1 \n 組員: \n \xa0 \xa0 \xa0 \xa0 40823108 \n \xa0 \xa0 \xa0 \xa0 40823109 \n \xa0 \xa0 \xa0 \xa0 40823112 \n \xa0 \xa0 \xa0 \xa0 40823145 \n 分組討論完，決定Stage2的 產品設計內容，為Stage1-ag1的產品進行改良，並新增其它功能: \n 1.利用鍵盤方向鍵操控 \n 2.增加接近傳感器使產品自動行走時，不會撞到障礙物 \n \n 本次專案沿用stage1-ag1之專案，為了讓模型能夠按照我們的意思做動，我們嘗試編寫Lua程式並以方向鍵進行控制。 \n 下方為第一次測試程式與模擬圖 \n \n Lua程式: \n threadFunction=function()\n    -- put your actuation code here\n while sim.getSimulationState()~=sim.simulation_advancing_abouttostop do\n    -- Read the keyboard messages (make sure the focus is on the main window, scene view):\n        message,auxiliaryData=sim.getSimulatorMessage()\n        while message~=-1 do\n            if (message==sim.message_keypress) then\nif (auxiliaryData[1]==2007) then\n                -- up key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                velocity=1000\n                torque=10000\n                Shape4 = 1000\n                Shape7 = 1000\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    if Shape4 == 1\n        then sim.setJointPosition(joint_1, 1000, orientation)\n    if Shape7 == 1\n        then sim.setJointPosition(joint_2, 1000, orientation)\n    end\n        sim.setJointTargetVelocity(joint,velocity)\n    end\n        joint_1=sim.getObjectHandle('joint_1')\n        joint_2=sim.getObjectHandle('joint_2')\n        Shape4=sim.getObjectHandle('Shape4')\n        Shape7=sim.getObjectHandle('Shape7')\n        velocity=0\n        torque=0\n        Shape4 = 0\n        Shape7 = 0\nend \n 因部分語法有誤，日後待除錯。 \n", 'tags': '', 'url': 'W5.html'}, {'title': 'W6', 'text': "\n 經過一週的時間，我們將程式進行了修改，但還是有錯誤，無法讓機構以上下左右鍵的方式進行控制。 \n 下方為模擬圖: \n \n 第二次Lua程式測試: \n function sysCall_init()\n    -- do some initialization here\n    left_front_handle= sim.getObjectHandle('left_front')\n    left_back_handle= sim.getObjectHandle('left_back')\n    right_back_handle= sim.getObjectHandle('right_back')\n    right_front_handle= sim.getObjectHandle('right_front')\n     \n    joint_1_handle= sim.getObjectHandle('joint_1')\n     \n    joint_2_handle= sim.getObjectHandle('joint_2')\n    MaxVel=10\n    leftvelocity=0\n    rightvelocity=0\n    dVel=0.5;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                 \n                 \n                sim.setJointForce(joint_1_handle, 1000)\n                 \n                sim.setJointForce(joint_2_handle, 1000)\n                break\n            else\n            --sim.setJointForce(left_front_handle, 10000)\n            sim.setJointForce(left_back_handle, 10000)\n            sim.setJointForce(right_back_handle, 10000)\n            --sim.setJointForce(right_front_handle, 10000)\n             \n            sim.setJointForce(joint_1_handle, 0)\n             \n            sim.setJointForce(joint_2_handle, 0)\n            end\n            if (auxiliaryData[1]==2007) then\n                -- up key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n     \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-MaxVel then\n        leftvelocity=-MaxVel\n    end\n     \n    if rightvelocity>MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-MaxVel then\n                rightvelocity=-MaxVel\n    end\n     \n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\n     \nend\n \nfunction sysCall_sensing()\n    -- put your sensing code here\nend\n \nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n \n-- See the user manual or the available code snippets for additional callback functions and details \n 第二次程式失敗，日後將持續進除錯。 \n \n \n", 'tags': '', 'url': 'W6.html'}, {'title': 'W7\xa0Keyboard Control', 'text': '利用鍵盤操控物體行走 \n \n ( 🔽程式碼 ) \n function sysCall_init() \n    left_front_handle= sim.getObjectHandle(\'left_m\')\n    left_back_handle= sim.getObjectHandle(\'left_m\')\n    right_back_handle= sim.getObjectHandle(\'right_m\')\n    right_front_handle= sim.getObjectHandle(\'right_m\')\n    MaxVel=2\n    leftvelocity=0\n    rightvelocity=0\n    dVel=0.5;\n    --sim.setJointTargetVelocity(left_front_handle,leftvelocity)\n    sim.setJointTargetVelocity(left_back_handle,leftvelocity)\n    sim.setJointTargetVelocity(right_back_handle,rightvelocity)\n    --sim.setJointTargetVelocity(right_front_handle,rightvelocity)\nend\n\nfunction sysCall_actuation() \n    message,auxiliaryData=sim.getSimulatorMessage()\n    while message~=-1 do\n        if (message==sim.message_keypress) then\n            if (auxiliaryData[1]==32) then\n                -- right key\n                leftvelocity=0\n                rightvelocity=0\n                sim.setJointForce(left_front_handle, 0)\n                sim.setJointForce(left_back_handle, 0)\n                sim.setJointForce(right_back_handle, 0)\n                sim.setJointForce(right_front_handle, 0)\n                break\n            else\n                --sim.setJointForce(left_front_handle, 10000)\n                sim.setJointForce(left_back_handle, 10000)\n                sim.setJointForce(right_back_handle, 10000)\n                --sim.setJointForce(right_front_handle, 10000)\n            end\n            if (auxiliaryData[1]==2007) then\n                -- up key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2008) then\n                -- down key\n                leftvelocity=(leftvelocity+rightvelocity)/2\n                rightvelocity=leftvelocity\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity-dVel\n            end\n            if (auxiliaryData[1]==2009) then\n                -- left key\n                leftvelocity=leftvelocity-dVel\n                rightvelocity=rightvelocity+dVel\n            end\n            if (auxiliaryData[1]==2010) then\n                -- right key\n                leftvelocity=leftvelocity+dVel\n                rightvelocity=rightvelocity-dVel\n            end\n        end\n        message,auxiliaryData=sim.getSimulatorMessage()\n    end\n    \n    if leftvelocity>MaxVel then\n        leftvelocity=MaxVel\n    end\n    if leftvelocity<-maxvel then="" leftvelocity="-MaxVel" end="" if="" rightvelocity="">MaxVel then\n                rightvelocity=MaxVel\n    end\n    if rightvelocity<-maxvel then="" rightvelocity="-MaxVel" end="" --sim="" setjointtargetvelocity="" left_front_handle="" leftvelocity="" sim="" setjointtargetvelocity="" left_back_handle="" leftvelocity="" sim="" setjointtargetvelocity="" right_back_handle="" rightvelocity="" --sim="" setjointtargetvelocity="" right_front_handle="" rightvelocity="" end="" pre=""> -maxvel -maxvel \n \n \n', 'tags': '', 'url': 'W7\xa0Keyboard Control.html'}, {'title': '模擬問題與排解', 'text': '問題:  當本體開啟運動模擬時會產生錯誤，導致產品解體 \n \n \n 問題原因:  討論後發現，產品的模擬干涉太多使其無法正常運作，原因是產品的輪子跟球體上並不是完整的圓，而是由許多正方形的小格子所構成，所以在模擬時產生過多的干涉影響電腦正常模擬，因而模擬錯誤。 \n \n \n 問題排解: \xa0在coppeliasim內 add->primitive shape->Cylinder 增添簡化圖形來代替原本的車輪，而原本的輪子就做為Disc的造型。 \n \n \n \n', 'tags': '', 'url': '模擬問題與排解.html'}, {'title': 'W8 Sensor Control', 'text': '增加接近傳感器使產品自動行走時，不會撞到障礙物 \n ( 🔽程式碼 ) \n function sysCall_init()\n    \n    \nend\n\nfunction sysCall_actuation()\n    \nend\n\nfunction sysCall_sensing()\n    \nend\n\nfunction sysCall_cleanup()\n    \nend\n\n\n\nfunction sysCall_afterDelete(inData)\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." was deleted")\n    end\n    \nend\n\nfunction sysCall_afterCreate(inData)\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..value.." was created")\n    end\nend\n--]]\nfunction speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    \n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) \n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") \n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") \n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") \n    minMaxSpeed={120*math.pi/180,300*math.pi/180} \n    backUntilTime=-1 \n   \n        xml = \' \'..[[\n         \n         \n         \n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*1\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) \n    \n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        \n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        \n        sim.setJointTargetVelocity(leftMotor,-speed/5)\n        sim.setJointTargetVelocity(rightMotor,-speed/200)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend\n \n \n', 'tags': '', 'url': 'W8 Sensor Control.html'}, {'title': 'Sensor模擬問題與排解', 'text': '問題: 程式與感測器都確認無誤後，卻還是無法做動。 \n \n \n 問題原因: 與組員討論後發現， 感測器都沒有發生問題，不會做動的原因是程式打錯才無法驅動馬達。 \n \n 問題排解: 更改產品物件的程式碼即可。 \n', 'tags': '', 'url': 'Sensor模擬問題與排解.html'}, {'title': 'W9', 'text': '程式模擬影片與PDF報告 \n 方向鍵控制模擬 \n \n 感測器模擬 \n \n PDF報告 \n', 'tags': '', 'url': 'W9.html'}]};